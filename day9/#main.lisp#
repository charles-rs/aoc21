(ql:quickload :cl-ppcre)

(defun get-nums ()
  (with-open-file (stream "input")
    (let ((lst (loop :for line = (read-line stream nil)
		     :while line
		     :collect (mapcar (lambda (x) (list (digit-char-p x))) (coerce line 'list)))))
      (make-array (list (length lst)
			(length (car lst)))
		  :initial-contents lst))))
(defun parta ()
  (let* ((nums (get-nums))
	 (dims (array-dimensions nums)))
    (labels ((get-pos (i j)
	       (if (and (>= i 0) (>= j 0)
			(< i (car dims)) (< j (cadr dims)))
		   (car (aref nums i j))
		   10))
	     (check-pos (i j)
	       (let ((cur (get-pos i j)))
		 (if (and (< cur (get-pos (1- i) j))
			  (< cur (get-pos (1+ i) j))
			  (< cur (get-pos i (1- j)))
			  (< cur (get-pos i (1+ j))))
		     (1+ cur)
		     0))))
      (loop :for i from 0 to (car dims)
	    :sum (loop :for j from 0 to (cadr dims)
		       :sum (check-pos i j))))))

(defun my-union (s1 s2)
  (union s1 s2 :test 'equal))

(defun partb ()
  (let* ((nums (get-nums))
	 (dims (array-dimensions nums)))
    (labels ((get-pos (i j)
	       (if (and (>= i 0) (>= j 0)
			(< i (car dims)) (< j (cadr dims)))
		   (car (aref nums i j))
		   10))
	     (check-pos (i j)
	       (let ((cur (get-pos i j)))
		 (and (< cur (get-pos (1- i) j))
		      (< cur (get-pos (1+ i) j))
		      (< cur (get-pos i (1- j)))
		      (< cur (get-pos i (1+ j))))))
	     (neighbors (i j)
	       (let ((cur (get-pos i j)))
		 (remove-if-not
		  (lambda (p) (and (/= 10 (get-pos (car p) (cdr p)))
				   (< cur (get-pos (car p) (cdr p)))))
		  (list (cons (1- i) j)
			(cons (1+ i) j)
			(cons i (1- j))
			(cons i (1+ j))))))
	     (get-basin (i j so-far)
	       (if (= 10 (get-pos i j))
		   so-far
		   (if (cdr (aref nums i j))
		       (my-union so-far (list (cons i j)))
		       (progn (setf (cdr (aref nums i j)) T)
			      (let ((others (loop :for pair in (neighbors i j)
						  :collect (get-basin (car pair)
								      (cdr pair)
								      (cons (cons i j) so-far)))))
				(reduce 'my-union others :initial-value so-far)))))))
      (let ((lens (sort
		   (mapcar 'length
			   (reduce 'my-union
				   (loop :for i from 0 to (car dims)
					 :collect
					 (loop :for j from 0 to (cadr dims)
					       :if (check-pos i j)
						 :collect
						 (remove-if
						  (lambda (pair)
						    (= 9 (get-pos (car pair) (cdr pair))))
						  (get-basin i j nil)))))) '>)))
	(* (car lens) (cadr lens) (caddr lens))))))
